; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: opt -passes=loop-unroll,instcombine -unroll-count=2 %s | llc --mattr=,+neon | FileCheck %s

target triple = "aarch64"

; This is a reduced example adapted from the Polybench 3MM kernel.
; We are doing something similar to:
;   double dot = 0.0;
;   for (long k = 0; k < 1000; k++)
;     dot += A[k] * B[k*nb];
;   return dot;

define double @test(ptr %A, ptr %B, i64 %nb) {
; CHECK-LABEL: test:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    movi d0, #0000000000000000
; CHECK-NEXT:    movi d1, #0000000000000000
; CHECK-NEXT:    lsl x8, x2, #4
; CHECK-NEXT:    mov x9, xzr
; CHECK-NEXT:  .LBB0_1: // %loop
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    add x10, x0, x9, lsl #3
; CHECK-NEXT:    ldr d2, [x1]
; CHECK-NEXT:    ldr d5, [x1, x2, lsl #3]
; CHECK-NEXT:    add x9, x9, #2
; CHECK-NEXT:    add x1, x1, x8
; CHECK-NEXT:    ldp d3, d4, [x10]
; CHECK-NEXT:    cmp x9, #1000
; CHECK-NEXT:    fmadd d0, d2, d3, d0
; CHECK-NEXT:    fmadd d1, d5, d4, d1
; CHECK-NEXT:    b.ne .LBB0_1
; CHECK-NEXT:  // %bb.2: // %exit
; CHECK-NEXT:    fadd d0, d0, d1
; CHECK-NEXT:    ret
entry:
  br label %loop

loop:
  %k = phi i64 [ %k.next, %loop ], [ 0, %entry ]
  %dot = phi double [ %dot.next, %loop ], [ 0.000000e+00, %entry ]
  %A.gep = getelementptr inbounds double, ptr %A, i64 %k
  %A.val = load double, ptr %A.gep, align 8
  %B.idx = mul nsw i64 %k, %nb
  %B.gep = getelementptr inbounds double, ptr %B, i64 %B.idx
  %B.val = load double, ptr %B.gep, align 8
  %fmul = fmul fast double %B.val, %A.val
  %dot.next = fadd fast double %fmul, %dot
  %k.next = add nuw nsw i64 %k, 1
  %cmp = icmp eq i64 %k.next, 1000
  br i1 %cmp, label %exit, label %loop

exit:
  %dot.next.lcssa = phi double [ %dot.next, %loop ]
  ret double %dot.next.lcssa
}
