; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=riscv32 -mattr=+d,+zfh,+zvfh,+v -target-abi=ilp32d \
; RUN:     -verify-machineinstrs < %s | FileCheck %s
; RUN: llc -mtriple=riscv64 -mattr=+d,+zfh,+zvfh,+v -target-abi=lp64d \
; RUN:     -verify-machineinstrs < %s | FileCheck %s

declare i32 @llvm.experimental.vp.popcount.v1i1(<1 x i1>, <1 x i1>, i32)
define i32 @vp_popcount_v1i1(<1 x i1> %m, <1 x i1> %op, i32 zeroext %evl) {
; CHECK-LABEL: vp_popcount_v1i1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a0, e8, mf8, ta, ma
; CHECK-NEXT:    vcpop.m a0, v8, v0.t
; CHECK-NEXT:    ret
entry:
  %a = call i32 @llvm.experimental.vp.popcount.v1i1(<1 x i1> %op, <1 x i1> %m, i32 %evl)
  ret i32 %a
}

define i32 @vp_popcount_v1i1_unmasked(<1 x i1> %op, i32 zeroext %evl) {
; CHECK-LABEL: vp_popcount_v1i1_unmasked:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a0, e8, mf8, ta, ma
; CHECK-NEXT:    vcpop.m a0, v0
; CHECK-NEXT:    ret
entry:
  %head = insertelement <1 x i1> poison, i1 true, i32 0
  %m = shufflevector <1 x i1> %head, <1 x i1> poison, <1 x i32> zeroinitializer
  %a = call i32 @llvm.experimental.vp.popcount.v1i1(<1 x i1> %op, <1 x i1> %m, i32 %evl)
  ret i32 %a
}

declare i32 @llvm.experimental.vp.popcount.v2i1(<2 x i1>, <2 x i1>, i32)
define i32 @vp_popcount_v2i1(<2 x i1> %m, <2 x i1> %op, i32 zeroext %evl) {
; CHECK-LABEL: vp_popcount_v2i1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a0, e8, mf8, ta, ma
; CHECK-NEXT:    vcpop.m a0, v8, v0.t
; CHECK-NEXT:    ret
entry:
  %a = call i32 @llvm.experimental.vp.popcount.v2i1(<2 x i1> %op, <2 x i1> %m, i32 %evl)
  ret i32 %a
}

define i32 @vp_popcount_v2i1_unmasked(<2 x i1> %op, i32 zeroext %evl) {
; CHECK-LABEL: vp_popcount_v2i1_unmasked:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a0, e8, mf8, ta, ma
; CHECK-NEXT:    vcpop.m a0, v0
; CHECK-NEXT:    ret
entry:
  %head = insertelement <2 x i1> poison, i1 true, i32 0
  %m = shufflevector <2 x i1> %head, <2 x i1> poison, <2 x i32> zeroinitializer
  %a = call i32 @llvm.experimental.vp.popcount.v2i1(<2 x i1> %op, <2 x i1> %m, i32 %evl)
  ret i32 %a
}

declare i32 @llvm.experimental.vp.popcount.v4i1(<4 x i1>, <4 x i1>, i32)
define i32 @vp_popcount_v4i1(<4 x i1> %m, <4 x i1> %op, i32 zeroext %evl) {
; CHECK-LABEL: vp_popcount_v4i1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a0, e8, mf4, ta, ma
; CHECK-NEXT:    vcpop.m a0, v8, v0.t
; CHECK-NEXT:    ret
entry:
  %a = call i32 @llvm.experimental.vp.popcount.v4i1(<4 x i1> %op, <4 x i1> %m, i32 %evl)
  ret i32 %a
}

define i32 @vp_popcount_v4i1_unmasked(<4 x i1> %op, i32 zeroext %evl) {
; CHECK-LABEL: vp_popcount_v4i1_unmasked:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a0, e8, mf4, ta, ma
; CHECK-NEXT:    vcpop.m a0, v0
; CHECK-NEXT:    ret
entry:
  %head = insertelement <4 x i1> poison, i1 true, i32 0
  %m = shufflevector <4 x i1> %head, <4 x i1> poison, <4 x i32> zeroinitializer
  %a = call i32 @llvm.experimental.vp.popcount.v4i1(<4 x i1> %op, <4 x i1> %m, i32 %evl)
  ret i32 %a
}

declare i32 @llvm.experimental.vp.popcount.v8i1(<8 x i1>, <8 x i1>, i32)
define i32 @vp_popcount_v8i1(<8 x i1> %m, <8 x i1> %op, i32 zeroext %evl) {
; CHECK-LABEL: vp_popcount_v8i1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a0, e8, mf2, ta, ma
; CHECK-NEXT:    vcpop.m a0, v8, v0.t
; CHECK-NEXT:    ret
entry:
  %a = call i32 @llvm.experimental.vp.popcount.v8i1(<8 x i1> %op, <8 x i1> %m, i32 %evl)
  ret i32 %a
}

define i32 @vp_popcount_v8i1_unmasked(<8 x i1> %op, i32 zeroext %evl) {
; CHECK-LABEL: vp_popcount_v8i1_unmasked:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a0, e8, mf2, ta, ma
; CHECK-NEXT:    vcpop.m a0, v0
; CHECK-NEXT:    ret
entry:
  %head = insertelement <8 x i1> poison, i1 true, i32 0
  %m = shufflevector <8 x i1> %head, <8 x i1> poison, <8 x i32> zeroinitializer
  %a = call i32 @llvm.experimental.vp.popcount.v8i1(<8 x i1> %op, <8 x i1> %m, i32 %evl)
  ret i32 %a
}

declare i32 @llvm.experimental.vp.popcount.v16i1(<16 x i1>, <16 x i1>, i32)
define i32 @vp_popcount_v16i1(<16 x i1> %m, <16 x i1> %op, i32 zeroext %evl) {
; CHECK-LABEL: vp_popcount_v16i1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a0, e8, m1, ta, ma
; CHECK-NEXT:    vcpop.m a0, v8, v0.t
; CHECK-NEXT:    ret
entry:
  %a = call i32 @llvm.experimental.vp.popcount.v16i1(<16 x i1> %op, <16 x i1> %m, i32 %evl)
  ret i32 %a
}

define i32 @vp_popcount_v16i1_unmasked(<16 x i1> %op, i32 zeroext %evl) {
; CHECK-LABEL: vp_popcount_v16i1_unmasked:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a0, e8, m1, ta, ma
; CHECK-NEXT:    vcpop.m a0, v0
; CHECK-NEXT:    ret
entry:
  %head = insertelement <16 x i1> poison, i1 true, i32 0
  %m = shufflevector <16 x i1> %head, <16 x i1> poison, <16 x i32> zeroinitializer
  %a = call i32 @llvm.experimental.vp.popcount.v16i1(<16 x i1> %op, <16 x i1> %m, i32 %evl)
  ret i32 %a
}

declare i32 @llvm.experimental.vp.popcount.v32i1(<32 x i1>, <32 x i1>, i32)
define i32 @vp_popcount_v32i1(<32 x i1> %m, <32 x i1> %op, i32 zeroext %evl) {
; CHECK-LABEL: vp_popcount_v32i1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a0, e8, m2, ta, ma
; CHECK-NEXT:    vcpop.m a0, v8, v0.t
; CHECK-NEXT:    ret
entry:
  %a = call i32 @llvm.experimental.vp.popcount.v32i1(<32 x i1> %op, <32 x i1> %m, i32 %evl)
  ret i32 %a
}

define i32 @vp_popcount_v32i1_unmasked(<32 x i1> %op, i32 zeroext %evl) {
; CHECK-LABEL: vp_popcount_v32i1_unmasked:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a0, e8, m2, ta, ma
; CHECK-NEXT:    vcpop.m a0, v0
; CHECK-NEXT:    ret
entry:
  %head = insertelement <32 x i1> poison, i1 true, i32 0
  %m = shufflevector <32 x i1> %head, <32 x i1> poison, <32 x i32> zeroinitializer
  %a = call i32 @llvm.experimental.vp.popcount.v32i1(<32 x i1> %op, <32 x i1> %m, i32 %evl)
  ret i32 %a
}

declare i32 @llvm.experimental.vp.popcount.v63i1(<63 x i1>, <63 x i1>, i32)
define i32 @vp_popcount_v63i1(<63 x i1> %m, <63 x i1> %op, i32 zeroext %evl) {
; CHECK-LABEL: vp_popcount_v63i1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a0, e8, m4, ta, ma
; CHECK-NEXT:    vcpop.m a0, v8, v0.t
; CHECK-NEXT:    ret
entry:
  %a = call i32 @llvm.experimental.vp.popcount.v63i1(<63 x i1> %op, <63 x i1> %m, i32 %evl)
  ret i32 %a
}

define i32 @vp_popcount_v63i1_unmasked(<63 x i1> %op, i32 zeroext %evl) {
; CHECK-LABEL: vp_popcount_v63i1_unmasked:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a0, e8, m4, ta, ma
; CHECK-NEXT:    vcpop.m a0, v0
; CHECK-NEXT:    ret
entry:
  %head = insertelement <63 x i1> poison, i1 true, i32 0
  %m = shufflevector <63 x i1> %head, <63 x i1> poison, <63 x i32> zeroinitializer
  %a = call i32 @llvm.experimental.vp.popcount.v63i1(<63 x i1> %op, <63 x i1> %m, i32 %evl)
  ret i32 %a
}

declare i32 @llvm.experimental.vp.popcount.v64i1(<64 x i1>, <64 x i1>, i32)
define i32 @vp_popcount_v64i1(<64 x i1> %m, <64 x i1> %op, i32 zeroext %evl) {
; CHECK-LABEL: vp_popcount_v64i1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a0, e8, m4, ta, ma
; CHECK-NEXT:    vcpop.m a0, v8, v0.t
; CHECK-NEXT:    ret
entry:
  %a = call i32 @llvm.experimental.vp.popcount.v64i1(<64 x i1> %op, <64 x i1> %m, i32 %evl)
  ret i32 %a
}

define i32 @vp_popcount_v64i1_unmasked(<64 x i1> %op, i32 zeroext %evl) {
; CHECK-LABEL: vp_popcount_v64i1_unmasked:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a0, e8, m4, ta, ma
; CHECK-NEXT:    vcpop.m a0, v0
; CHECK-NEXT:    ret
entry:
  %head = insertelement <64 x i1> poison, i1 true, i32 0
  %m = shufflevector <64 x i1> %head, <64 x i1> poison, <64 x i32> zeroinitializer
  %a = call i32 @llvm.experimental.vp.popcount.v64i1(<64 x i1> %op, <64 x i1> %m, i32 %evl)
  ret i32 %a
}

declare i32 @llvm.experimental.vp.popcount.v128i1(<128 x i1>, <128 x i1>, i32)
define i32 @vp_popcount_v128i1(<128 x i1> %m, <128 x i1> %op, i32 zeroext %evl) {
; CHECK-LABEL: vp_popcount_v128i1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a0, e8, m8, ta, ma
; CHECK-NEXT:    vcpop.m a0, v8, v0.t
; CHECK-NEXT:    ret
entry:
  %a = call i32 @llvm.experimental.vp.popcount.v128i1(<128 x i1> %op, <128 x i1> %m, i32 %evl)
  ret i32 %a
}

define i32 @vp_popcount_v128i1_unmasked(<128 x i1> %op, i32 zeroext %evl) {
; CHECK-LABEL: vp_popcount_v128i1_unmasked:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a0, e8, m8, ta, ma
; CHECK-NEXT:    vcpop.m a0, v0
; CHECK-NEXT:    ret
entry:
  %head = insertelement <128 x i1> poison, i1 true, i32 0
  %m = shufflevector <128 x i1> %head, <128 x i1> poison, <128 x i32> zeroinitializer
  %a = call i32 @llvm.experimental.vp.popcount.v128i1(<128 x i1> %op, <128 x i1> %m, i32 %evl)
  ret i32 %a
}

declare i32 @llvm.experimental.vp.popcount.v256i1(<256 x i1>, <256 x i1>, i32)
define i32 @vp_popcount_v256i1(<256 x i1> %m, <256 x i1> %op, i32 zeroext %evl) {
; CHECK-LABEL: vp_popcount_v256i1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    li a2, 128
; CHECK-NEXT:    mv a1, a0
; CHECK-NEXT:    bltu a0, a2, .LBB18_2
; CHECK-NEXT:  # %bb.1: # %entry
; CHECK-NEXT:    li a1, 128
; CHECK-NEXT:  .LBB18_2: # %entry
; CHECK-NEXT:    vsetvli zero, a1, e8, m8, ta, ma
; CHECK-NEXT:    vcpop.m a1, v9, v0.t
; CHECK-NEXT:    addi a2, a0, -128
; CHECK-NEXT:    sltu a0, a0, a2
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    and a0, a0, a2
; CHECK-NEXT:    vsetvli zero, a0, e8, m8, ta, ma
; CHECK-NEXT:    vmv1r.v v0, v8
; CHECK-NEXT:    vcpop.m a0, v10, v0.t
; CHECK-NEXT:    add a0, a1, a0
; CHECK-NEXT:    ret
entry:
  %a = call i32 @llvm.experimental.vp.popcount.v256i1(<256 x i1> %op, <256 x i1> %m, i32 %evl)
  ret i32 %a
}

define i32 @vp_popcount_v256i1_unmasked(<256 x i1> %op, i32 zeroext %evl) {
; CHECK-LABEL: vp_popcount_v256i1_unmasked:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    li a2, 128
; CHECK-NEXT:    mv a1, a0
; CHECK-NEXT:    bltu a0, a2, .LBB19_2
; CHECK-NEXT:  # %bb.1: # %entry
; CHECK-NEXT:    li a1, 128
; CHECK-NEXT:  .LBB19_2: # %entry
; CHECK-NEXT:    vsetvli zero, a1, e8, m8, ta, ma
; CHECK-NEXT:    vcpop.m a1, v0
; CHECK-NEXT:    addi a2, a0, -128
; CHECK-NEXT:    sltu a0, a0, a2
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    and a0, a0, a2
; CHECK-NEXT:    vsetvli zero, a0, e8, m8, ta, ma
; CHECK-NEXT:    vcpop.m a0, v8
; CHECK-NEXT:    add a0, a1, a0
; CHECK-NEXT:    ret
entry:
  %head = insertelement <256 x i1> poison, i1 true, i32 0
  %m = shufflevector <256 x i1> %head, <256 x i1> poison, <256 x i32> zeroinitializer
  %a = call i32 @llvm.experimental.vp.popcount.v256i1(<256 x i1> %op, <256 x i1> %m, i32 %evl)
  ret i32 %a
}
