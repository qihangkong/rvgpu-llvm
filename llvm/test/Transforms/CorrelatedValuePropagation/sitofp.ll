; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=correlated-propagation -S | FileCheck %s

declare void @use.f32(float)

define void @test1_fptosi(i32 %n) {
; CHECK-LABEL: @test1_fptosi(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[A:%.*]] = phi i32 [ [[N:%.*]], [[ENTRY:%.*]] ], [ [[EXT:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[A]], -1
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_END:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[EXT_WIDE:%.*]] = uitofp nneg i32 [[A]] to float
; CHECK-NEXT:    call void @use.f32(float [[EXT_WIDE]])
; CHECK-NEXT:    [[EXT]] = fptosi float [[EXT_WIDE]] to i32
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.end:
; CHECK-NEXT:    ret void
;
entry:
  br label %for.cond

for.cond:  ; preds = %for.body, %entry
  %a = phi i32 [ %n, %entry ], [ %ext, %for.body ]
  %cmp = icmp sgt i32 %a, -1
  br i1 %cmp, label %for.body, label %for.end

for.body:  ; preds = %for.cond
  %ext.wide = sitofp i32 %a to float
  call void @use.f32(float %ext.wide)
  %ext = fptosi float %ext.wide to i32
  br label %for.cond

for.end:  ; preds = %for.cond
  ret void
}

define void @test1_fptoui(i32 %n) {
; CHECK-LABEL: @test1_fptoui(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[A:%.*]] = phi i32 [ [[N:%.*]], [[ENTRY:%.*]] ], [ [[EXT:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[A]], -1
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_END:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[EXT_WIDE:%.*]] = uitofp nneg i32 [[A]] to float
; CHECK-NEXT:    call void @use.f32(float [[EXT_WIDE]])
; CHECK-NEXT:    [[EXT]] = fptoui float [[EXT_WIDE]] to i32
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.end:
; CHECK-NEXT:    ret void
;
entry:
  br label %for.cond

for.cond:  ; preds = %for.body, %entry
  %a = phi i32 [ %n, %entry ], [ %ext, %for.body ]
  %cmp = icmp sgt i32 %a, -1
  br i1 %cmp, label %for.body, label %for.end

for.body:  ; preds = %for.cond
  %ext.wide = sitofp i32 %a to float
  call void @use.f32(float %ext.wide)
  %ext = fptoui float %ext.wide to i32
  br label %for.cond

for.end:  ; preds = %for.cond
  ret void
}

;; Negative test to show transform doesn't happen unless n >= 0.
define void @test2(i32 %n) {
; CHECK-LABEL: @test2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[A:%.*]] = phi i32 [ [[N:%.*]], [[ENTRY:%.*]] ], [ [[EXT:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[A]], -2
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_END:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[EXT_WIDE:%.*]] = sitofp i32 [[A]] to float
; CHECK-NEXT:    call void @use.f32(float [[EXT_WIDE]])
; CHECK-NEXT:    [[EXT]] = fptosi float [[EXT_WIDE]] to i32
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.end:
; CHECK-NEXT:    ret void
;
entry:
  br label %for.cond

for.cond:  ; preds = %for.body, %entry
  %a = phi i32 [ %n, %entry ], [ %ext, %for.body ]
  %cmp = icmp sgt i32 %a, -2
  br i1 %cmp, label %for.body, label %for.end

for.body:  ; preds = %for.cond
  %ext.wide = sitofp i32 %a to float
  call void @use.f32(float %ext.wide)
  %ext = fptosi float %ext.wide to i32
  br label %for.cond

for.end:  ; preds = %for.cond
  ret void
}

;; Non looping test case.
define void @test3(i32 %n) {
; CHECK-LABEL: @test3(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[N:%.*]], -1
; CHECK-NEXT:    br i1 [[CMP]], label [[BB:%.*]], label [[EXIT:%.*]]
; CHECK:       bb:
; CHECK-NEXT:    [[EXT_WIDE:%.*]] = uitofp nneg i32 [[N]] to float
; CHECK-NEXT:    call void @use.f32(float [[EXT_WIDE]])
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %cmp = icmp sgt i32 %n, -1
  br i1 %cmp, label %bb, label %exit

bb:
  %ext.wide = sitofp i32 %n to float
  call void @use.f32(float %ext.wide)
  br label %exit

exit:
  ret void
}

;; Non looping negative test case.
define void @test4(i32 %n) {
; CHECK-LABEL: @test4(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[N:%.*]], -2
; CHECK-NEXT:    br i1 [[CMP]], label [[BB:%.*]], label [[EXIT:%.*]]
; CHECK:       bb:
; CHECK-NEXT:    [[EXT_WIDE:%.*]] = sitofp i32 [[N]] to float
; CHECK-NEXT:    call void @use.f32(float [[EXT_WIDE]])
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %cmp = icmp sgt i32 %n, -2
  br i1 %cmp, label %bb, label %exit

bb:
  %ext.wide = sitofp i32 %n to float
  call void @use.f32(float %ext.wide)
  br label %exit

exit:
  ret void
}

define float @may_including_undef(i1 %c.1, i1 %c.2) {
; CHECK-LABEL: @may_including_undef(
; CHECK-NEXT:    br i1 [[C_1:%.*]], label [[TRUE_1:%.*]], label [[FALSE:%.*]]
; CHECK:       true.1:
; CHECK-NEXT:    br i1 [[C_2:%.*]], label [[TRUE_2:%.*]], label [[EXIT:%.*]]
; CHECK:       true.2:
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       false:
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    [[P:%.*]] = phi i32 [ 0, [[TRUE_1]] ], [ 1, [[TRUE_2]] ], [ undef, [[FALSE]] ]
; CHECK-NEXT:    [[EXT:%.*]] = sitofp i32 [[P]] to float
; CHECK-NEXT:    ret float [[EXT]]
;
  br i1 %c.1, label %true.1, label %false

true.1:
  br i1 %c.2, label %true.2, label %exit

true.2:
  br label %exit

false:
  br label %exit

exit:
  %p = phi i32 [ 0, %true.1 ], [ 1, %true.2], [ undef, %false ]
  %ext = sitofp i32 %p to float
  ret float %ext
}

define double @test_infer_at_use(i32 noundef %n) {
; CHECK-LABEL: @test_infer_at_use(
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[N:%.*]], -1
; CHECK-NEXT:    [[EXT:%.*]] = uitofp nneg i32 [[N]] to double
; CHECK-NEXT:    [[SELECT:%.*]] = select i1 [[CMP]], double [[EXT]], double 0.000000e+00
; CHECK-NEXT:    ret double [[SELECT]]
;
  %cmp = icmp sgt i32 %n, -1
  %ext = sitofp i32 %n to double
  %select = select i1 %cmp, double %ext, double 0.0
  ret double %select
}
