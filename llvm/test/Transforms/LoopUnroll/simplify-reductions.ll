; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -passes=loop-unroll -unroll-count=2 -unroll-simplify-reductions=true < %s | FileCheck %s

; The loops below are variations of:
;   double sum = 0;
;   for(long i = 0; i < 1000; i++)
;     sum += A[i];
;   return sum;

; Positive test, simple case.
define double @p1(ptr %A) {
; CHECK-LABEL: @p1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[I:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[I_NEXT_1:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[SUM:%.*]] = phi double [ 0.000000e+00, [[ENTRY]] ], [ [[SUM_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[SUM1:%.*]] = phi double [ 0.000000e+00, [[ENTRY]] ], [ [[SUM_NEXT_1:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[A_GEP:%.*]] = getelementptr inbounds double, ptr [[A:%.*]], i64 [[I]]
; CHECK-NEXT:    [[A_VAL:%.*]] = load double, ptr [[A_GEP]], align 8
; CHECK-NEXT:    [[SUM_NEXT]] = fadd fast double [[A_VAL]], [[SUM]]
; CHECK-NEXT:    [[I_NEXT:%.*]] = add nuw nsw i64 [[I]], 1
; CHECK-NEXT:    [[A_GEP_1:%.*]] = getelementptr inbounds double, ptr [[A]], i64 [[I_NEXT]]
; CHECK-NEXT:    [[A_VAL_1:%.*]] = load double, ptr [[A_GEP_1]], align 8
; CHECK-NEXT:    [[SUM_NEXT_1]] = fadd fast double [[A_VAL_1]], [[SUM1]]
; CHECK-NEXT:    [[I_NEXT_1]] = add nuw nsw i64 [[I]], 2
; CHECK-NEXT:    [[CMP_1:%.*]] = icmp eq i64 [[I_NEXT_1]], 1000
; CHECK-NEXT:    [[SUM_RED:%.*]] = fadd fast double [[SUM_NEXT]], [[SUM_NEXT_1]]
; CHECK-NEXT:    br i1 [[CMP_1]], label [[EXIT:%.*]], label [[LOOP]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       exit:
; CHECK-NEXT:    [[SUM_LCSSA:%.*]] = phi double [ [[SUM_RED]], [[LOOP]] ]
; CHECK-NEXT:    ret double [[SUM_LCSSA]]
;
entry:
  br label %loop

loop:
  %i = phi i64 [ %i.next, %loop ], [ 0, %entry ]
  %sum = phi double [ %sum.next, %loop ], [ 0.000000e+00, %entry ]
  %A.gep = getelementptr inbounds double, ptr %A, i64 %i
  %A.val = load double, ptr %A.gep, align 8
  %sum.next = fadd fast double %A.val, %sum
  %i.next = add nuw nsw i64 %i, 1
  %cmp = icmp eq i64 %i.next, 1000
  br i1 %cmp, label %exit, label %loop

exit:
  %sum.lcssa = phi double [ %sum.next, %loop ]
  ret double %sum.lcssa
}

; Positive test, non-zero starting sum.
define double @p2(ptr %A, double %acc) {
; CHECK-LABEL: @p2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[I:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[I_NEXT_1:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[SUM:%.*]] = phi double [ [[ACC:%.*]], [[ENTRY]] ], [ [[SUM_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[SUM1:%.*]] = phi double [ 0.000000e+00, [[ENTRY]] ], [ [[SUM_NEXT_1:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[A_GEP:%.*]] = getelementptr inbounds double, ptr [[A:%.*]], i64 [[I]]
; CHECK-NEXT:    [[A_VAL:%.*]] = load double, ptr [[A_GEP]], align 8
; CHECK-NEXT:    [[SUM_NEXT]] = fadd fast double [[A_VAL]], [[SUM]]
; CHECK-NEXT:    [[I_NEXT:%.*]] = add nuw nsw i64 [[I]], 1
; CHECK-NEXT:    [[A_GEP_1:%.*]] = getelementptr inbounds double, ptr [[A]], i64 [[I_NEXT]]
; CHECK-NEXT:    [[A_VAL_1:%.*]] = load double, ptr [[A_GEP_1]], align 8
; CHECK-NEXT:    [[SUM_NEXT_1]] = fadd fast double [[A_VAL_1]], [[SUM1]]
; CHECK-NEXT:    [[I_NEXT_1]] = add nuw nsw i64 [[I]], 2
; CHECK-NEXT:    [[CMP_1:%.*]] = icmp eq i64 [[I_NEXT_1]], 1000
; CHECK-NEXT:    [[SUM_RED:%.*]] = fadd fast double [[SUM_NEXT]], [[SUM_NEXT_1]]
; CHECK-NEXT:    br i1 [[CMP_1]], label [[EXIT:%.*]], label [[LOOP]], !llvm.loop [[LOOP2:![0-9]+]]
; CHECK:       exit:
; CHECK-NEXT:    [[SUM_LCSSA:%.*]] = phi double [ [[SUM_RED]], [[LOOP]] ]
; CHECK-NEXT:    ret double [[SUM_LCSSA]]
;
entry:
  br label %loop

loop:
  %i = phi i64 [ %i.next, %loop ], [ 0, %entry ]
  %sum = phi double [ %sum.next, %loop ], [ %acc, %entry ]
  %A.gep = getelementptr inbounds double, ptr %A, i64 %i
  %A.val = load double, ptr %A.gep, align 8
  %sum.next = fadd fast double %A.val, %sum
  %i.next = add nuw nsw i64 %i, 1
  %cmp = icmp eq i64 %i.next, 1000
  br i1 %cmp, label %exit, label %loop

exit:
  %sum.lcssa = phi double [ %sum.next, %loop ]
  ret double %sum.lcssa
}

; Positive test, non-floating-point type.
define i64 @p3(ptr %A) {
; CHECK-LABEL: @p3(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[I:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[I_NEXT_1:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[AND:%.*]] = phi i64 [ -1, [[ENTRY]] ], [ [[AND_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[AND1:%.*]] = phi i64 [ -1, [[ENTRY]] ], [ [[AND_NEXT_1:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[A_GEP:%.*]] = getelementptr inbounds i64, ptr [[A:%.*]], i64 [[I]]
; CHECK-NEXT:    [[A_VAL:%.*]] = load i64, ptr [[A_GEP]], align 8
; CHECK-NEXT:    [[AND_NEXT]] = and i64 [[A_VAL]], [[AND]]
; CHECK-NEXT:    [[I_NEXT:%.*]] = add nuw nsw i64 [[I]], 1
; CHECK-NEXT:    [[A_GEP_1:%.*]] = getelementptr inbounds i64, ptr [[A]], i64 [[I_NEXT]]
; CHECK-NEXT:    [[A_VAL_1:%.*]] = load i64, ptr [[A_GEP_1]], align 8
; CHECK-NEXT:    [[AND_NEXT_1]] = and i64 [[A_VAL_1]], [[AND1]]
; CHECK-NEXT:    [[I_NEXT_1]] = add nuw nsw i64 [[I]], 2
; CHECK-NEXT:    [[CMP_1:%.*]] = icmp eq i64 [[I_NEXT_1]], 1000
; CHECK-NEXT:    [[AND_RED:%.*]] = and i64 [[AND_NEXT]], [[AND_NEXT_1]]
; CHECK-NEXT:    br i1 [[CMP_1]], label [[EXIT:%.*]], label [[LOOP]], !llvm.loop [[LOOP3:![0-9]+]]
; CHECK:       exit:
; CHECK-NEXT:    [[AND_LCSSA:%.*]] = phi i64 [ [[AND_RED]], [[LOOP]] ]
; CHECK-NEXT:    ret i64 [[AND_LCSSA]]
;
entry:
  br label %loop

loop:
  %i = phi i64 [ %i.next, %loop ], [ 0, %entry ]
  %and = phi i64 [ %and.next, %loop ], [ -1, %entry ]
  %A.gep = getelementptr inbounds i64, ptr %A, i64 %i
  %A.val = load i64, ptr %A.gep, align 8
  %and.next = and i64 %A.val, %and
  %i.next = add nuw nsw i64 %i, 1
  %cmp = icmp eq i64 %i.next, 1000
  br i1 %cmp, label %exit, label %loop

exit:
  %and.lcssa = phi i64 [ %and.next, %loop ]
  ret i64 %and.lcssa
}

; Negative test: Sum is used in the loop, which prevents breaking the
; reduction.
define double @n1(ptr %A) {
; CHECK-LABEL: @n1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[I:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[I_NEXT_1:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[SUM:%.*]] = phi double [ 0.000000e+00, [[ENTRY]] ], [ [[SUM_NEXT_1:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[A_GEP:%.*]] = getelementptr inbounds double, ptr [[A:%.*]], i64 [[I]]
; CHECK-NEXT:    [[A_VAL:%.*]] = load double, ptr [[A_GEP]], align 8
; CHECK-NEXT:    [[SUM_NEXT:%.*]] = fadd fast double [[A_VAL]], [[SUM]]
; CHECK-NEXT:    store double [[SUM_NEXT]], ptr [[A_GEP]], align 8
; CHECK-NEXT:    [[I_NEXT:%.*]] = add nuw nsw i64 [[I]], 1
; CHECK-NEXT:    [[A_GEP_1:%.*]] = getelementptr inbounds double, ptr [[A]], i64 [[I_NEXT]]
; CHECK-NEXT:    [[A_VAL_1:%.*]] = load double, ptr [[A_GEP_1]], align 8
; CHECK-NEXT:    [[SUM_NEXT_1]] = fadd fast double [[A_VAL_1]], [[SUM_NEXT]]
; CHECK-NEXT:    store double [[SUM_NEXT_1]], ptr [[A_GEP_1]], align 8
; CHECK-NEXT:    [[I_NEXT_1]] = add nuw nsw i64 [[I]], 2
; CHECK-NEXT:    [[CMP_1:%.*]] = icmp eq i64 [[I_NEXT_1]], 1000
; CHECK-NEXT:    br i1 [[CMP_1]], label [[EXIT:%.*]], label [[LOOP]], !llvm.loop [[LOOP4:![0-9]+]]
; CHECK:       exit:
; CHECK-NEXT:    [[SUM_LCSSA:%.*]] = phi double [ [[SUM_NEXT_1]], [[LOOP]] ]
; CHECK-NEXT:    ret double [[SUM_LCSSA]]
;
entry:
  br label %loop

loop:
  %i = phi i64 [ %i.next, %loop ], [ 0, %entry ]
  %sum = phi double [ %sum.next, %loop ], [ 0.000000e+00, %entry ]
  %A.gep = getelementptr inbounds double, ptr %A, i64 %i
  %A.val = load double, ptr %A.gep, align 8
  %sum.next = fadd fast double %A.val, %sum
  store double %sum.next, ptr %A.gep
  %i.next = add nuw nsw i64 %i, 1
  %cmp = icmp eq i64 %i.next, 1000
  br i1 %cmp, label %exit, label %loop

exit:
  %sum.lcssa = phi double [ %sum.next, %loop ]
  ret double %sum.lcssa
}

; Negative test: Reduction op is not associative or commutative.
define double @n2(ptr %A) {
; CHECK-LABEL: @n2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[I:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[I_NEXT_1:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[SUM:%.*]] = phi double [ 0.000000e+00, [[ENTRY]] ], [ [[SUM_NEXT_1:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[A_GEP:%.*]] = getelementptr inbounds double, ptr [[A:%.*]], i64 [[I]]
; CHECK-NEXT:    [[A_VAL:%.*]] = load double, ptr [[A_GEP]], align 8
; CHECK-NEXT:    [[SUM_NEXT:%.*]] = fadd double [[A_VAL]], [[SUM]]
; CHECK-NEXT:    [[I_NEXT:%.*]] = add nuw nsw i64 [[I]], 1
; CHECK-NEXT:    [[A_GEP_1:%.*]] = getelementptr inbounds double, ptr [[A]], i64 [[I_NEXT]]
; CHECK-NEXT:    [[A_VAL_1:%.*]] = load double, ptr [[A_GEP_1]], align 8
; CHECK-NEXT:    [[SUM_NEXT_1]] = fadd double [[A_VAL_1]], [[SUM_NEXT]]
; CHECK-NEXT:    [[I_NEXT_1]] = add nuw nsw i64 [[I]], 2
; CHECK-NEXT:    [[CMP_1:%.*]] = icmp eq i64 [[I_NEXT_1]], 1000
; CHECK-NEXT:    br i1 [[CMP_1]], label [[EXIT:%.*]], label [[LOOP]], !llvm.loop [[LOOP5:![0-9]+]]
; CHECK:       exit:
; CHECK-NEXT:    [[SUM_LCSSA:%.*]] = phi double [ [[SUM_NEXT_1]], [[LOOP]] ]
; CHECK-NEXT:    ret double [[SUM_LCSSA]]
;
entry:
  br label %loop

loop:
  %i = phi i64 [ %i.next, %loop ], [ 0, %entry ]
  %sum = phi double [ %sum.next, %loop ], [ 0.000000e+00, %entry ]
  %A.gep = getelementptr inbounds double, ptr %A, i64 %i
  %A.val = load double, ptr %A.gep, align 8
  %sum.next = fadd double %A.val, %sum
  %i.next = add nuw nsw i64 %i, 1
  %cmp = icmp eq i64 %i.next, 1000
  br i1 %cmp, label %exit, label %loop

exit:
  %sum.lcssa = phi double [ %sum.next, %loop ]
  ret double %sum.lcssa
}

; Negative test: Reduction op is unsupported.
define double @n3(ptr %A) {
; CHECK-LABEL: @n3(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[I:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[I_NEXT_1:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[PROD:%.*]] = phi double [ 1.000000e+00, [[ENTRY]] ], [ [[PROD_NEXT_1:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[A_GEP:%.*]] = getelementptr inbounds double, ptr [[A:%.*]], i64 [[I]]
; CHECK-NEXT:    [[A_VAL:%.*]] = load double, ptr [[A_GEP]], align 8
; CHECK-NEXT:    [[PROD_NEXT:%.*]] = fmul fast double [[A_VAL]], [[PROD]]
; CHECK-NEXT:    [[I_NEXT:%.*]] = add nuw nsw i64 [[I]], 1
; CHECK-NEXT:    [[A_GEP_1:%.*]] = getelementptr inbounds double, ptr [[A]], i64 [[I_NEXT]]
; CHECK-NEXT:    [[A_VAL_1:%.*]] = load double, ptr [[A_GEP_1]], align 8
; CHECK-NEXT:    [[PROD_NEXT_1]] = fmul fast double [[A_VAL_1]], [[PROD_NEXT]]
; CHECK-NEXT:    [[I_NEXT_1]] = add nuw nsw i64 [[I]], 2
; CHECK-NEXT:    [[CMP_1:%.*]] = icmp eq i64 [[I_NEXT_1]], 1000
; CHECK-NEXT:    br i1 [[CMP_1]], label [[EXIT:%.*]], label [[LOOP]], !llvm.loop [[LOOP6:![0-9]+]]
; CHECK:       exit:
; CHECK-NEXT:    [[PROD_LCSSA:%.*]] = phi double [ [[PROD_NEXT_1]], [[LOOP]] ]
; CHECK-NEXT:    ret double [[PROD_LCSSA]]
;
entry:
  br label %loop

loop:
  %i = phi i64 [ %i.next, %loop ], [ 0, %entry ]
  %prod = phi double [ %prod.next, %loop ], [ 1.000000e+00, %entry ]
  %A.gep = getelementptr inbounds double, ptr %A, i64 %i
  %A.val = load double, ptr %A.gep, align 8
  %prod.next = fmul fast double %A.val, %prod
  %i.next = add nuw nsw i64 %i, 1
  %cmp = icmp eq i64 %i.next, 1000
  br i1 %cmp, label %exit, label %loop

exit:
  %prod.lcssa = phi double [ %prod.next, %loop ]
  ret double %prod.lcssa
}

; Negative test: Chain of different operations.
define i64 @n4(ptr %A) {
; CHECK-LABEL: @n4(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[I:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[I_NEXT_1:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[RED:%.*]] = phi i64 [ 0, [[ENTRY]] ], [ [[RED_NEXT_1:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[A_GEP:%.*]] = getelementptr inbounds i64, ptr [[A:%.*]], i64 [[I]]
; CHECK-NEXT:    [[A_VAL:%.*]] = load i64, ptr [[A_GEP]], align 8
; CHECK-NEXT:    [[RED_TEMP:%.*]] = add i64 [[A_VAL]], [[RED]]
; CHECK-NEXT:    [[RED_NEXT:%.*]] = and i64 [[RED_TEMP]], 7
; CHECK-NEXT:    [[I_NEXT:%.*]] = add nuw nsw i64 [[I]], 1
; CHECK-NEXT:    [[A_GEP_1:%.*]] = getelementptr inbounds i64, ptr [[A]], i64 [[I_NEXT]]
; CHECK-NEXT:    [[A_VAL_1:%.*]] = load i64, ptr [[A_GEP_1]], align 8
; CHECK-NEXT:    [[RED_TEMP_1:%.*]] = add i64 [[A_VAL_1]], [[RED_NEXT]]
; CHECK-NEXT:    [[RED_NEXT_1]] = and i64 [[RED_TEMP_1]], 7
; CHECK-NEXT:    [[I_NEXT_1]] = add nuw nsw i64 [[I]], 2
; CHECK-NEXT:    [[CMP_1:%.*]] = icmp eq i64 [[I_NEXT_1]], 1000
; CHECK-NEXT:    br i1 [[CMP_1]], label [[EXIT:%.*]], label [[LOOP]], !llvm.loop [[LOOP7:![0-9]+]]
; CHECK:       exit:
; CHECK-NEXT:    [[RED_LCSSA:%.*]] = phi i64 [ [[RED_NEXT_1]], [[LOOP]] ]
; CHECK-NEXT:    ret i64 [[RED_LCSSA]]
;
entry:
  br label %loop

loop:
  %i = phi i64 [ %i.next, %loop ], [ 0, %entry ]
  %red = phi i64 [ %red.next, %loop ], [ 0, %entry ]
  %A.gep = getelementptr inbounds i64, ptr %A, i64 %i
  %A.val = load i64, ptr %A.gep, align 8
  %red.temp = add i64 %A.val, %red
  %red.next = and i64 %red.temp, 7
  %i.next = add nuw nsw i64 %i, 1
  %cmp = icmp eq i64 %i.next, 1000
  br i1 %cmp, label %exit, label %loop

exit:
  %red.lcssa = phi i64 [ %red.next, %loop ]
  ret i64 %red.lcssa
}
