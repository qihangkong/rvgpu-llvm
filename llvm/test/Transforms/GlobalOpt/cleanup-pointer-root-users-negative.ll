; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -passes=globalopt < %s -S | FileCheck %s

@gv = internal unnamed_addr global [3 x ptr] zeroinitializer, align 16
@gv2 = internal unnamed_addr global i32 0, align 4

;; This test includes a load from @gv. No stores
;; or memintrinsics with destination @gv should be removed.
define i32 @main_with_load_from_b() local_unnamed_addr {
; CHECK-LABEL: define i32 @main_with_load_from_b() local_unnamed_addr {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[E:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store ptr [[E]], ptr getelementptr inbounds ([3 x ptr], ptr @gv, i64 0, i64 2), align 16
; CHECK-NEXT:    [[LOAD_B:%.*]] = load ptr, ptr getelementptr inbounds ([3 x ptr], ptr @gv, i64 0, i64 2), align 16
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr @gv, ptr null, i64 8, i1 false)
; CHECK-NEXT:    ret i32 0
;
entry:
  %e = alloca i32, align 4
  store ptr %e, ptr getelementptr inbounds ([3 x ptr], ptr @gv, i64 0, i64 2), align 16
  %load.b = load ptr, ptr getelementptr inbounds ([3 x ptr], ptr @gv, i64 0, i64 2), align 16
  call void @llvm.memcpy.p0i8.p0i8.i64(ptr getelementptr inbounds ([3 x ptr], ptr @gv, i64 0, i64 0), ptr null, i64 8, i1 false)
  ret i32 0
}

;; This test includes a memcpy with @c as it's source and destination
;; operands. CleanupPointerRootUsers is not called in this case.
define i32 @main_with_load_store_c() local_unnamed_addr {
; CHECK-LABEL: define i32 @main_with_load_store_c() local_unnamed_addr {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[E:%.*]] = alloca i32, align 4
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr @gv2, ptr @gv2, i64 4, i1 false)
; CHECK-NEXT:    ret i32 0
;
entry:
  %e = alloca i32, align 4
  call void @llvm.memcpy.p0i8.p0i8.i64(ptr @gv2, ptr @gv2, i64 4, i1 false)
  ret i32 0
}

declare void @llvm.memcpy.p0i8.p0i8.i64(ptr nocapture, ptr nocapture readonly, i64, i1) local_unnamed_addr
declare void @llvm.memset.p0i8.i64(ptr nocapture, i8, i64, i1) local_unnamed_addr
